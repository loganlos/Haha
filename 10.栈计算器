#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <math.h>
#define PI 3.1415926 // 圆周率

typedef struct {
    double* data;
    int top;
    int capacity;
} Stack;

void initStack(Stack* stack, int capacity) {
    stack->data = (double*)malloc(capacity * sizeof(double));
    stack->top = -1;
    stack->capacity = capacity;
}

bool isEmpty(Stack* stack) {
    return stack->top == -1;
}

bool isFull(Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(Stack* stack, double value) {
    if (isFull(stack)) {
        printf("Stack overflow\n");
        return;
    }
    stack->data[++stack->top] = value;
}

double pop(Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack underflow\n");
        return 0.0;
    }
    return stack->data[stack->top--];
}

double peek(Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty\n");
        return 0.0;
    }
    return stack->data[stack->top];
}

int getPriority(char op) {
    if (op == '+' || op == '-')
        return 1;
    else if (op == '*' || op == '/')
        return 2;
    else if (op == '^')
        return 3;
    else if (op == '(')
        return 0;
    else
        return -1;
}

double calculate(double num1, double num2, char op) {
    switch (op) {
        case '+':
            return num1 + num2;
        case '-':
            return num1 - num2;
        case '*':
            return num1 * num2;
        case '/':
            return num1 / num2;
        case '^':
            return pow(num1, num2);
        default:
            return 0.0;
    }
}

/*判断是否为外加函数*/
int istri(char c)
{
    switch(c)
    {
        case 's':return 1;
        case 'c':return 2;
        case 't':return 3;
        case 'e':return 4;
        case 'l':return 5;
        default :return 0;
    }
}


double evaluateExpression(char* expression) {
    Stack operatorStack;
    Stack operandStack;
    initStack(&operatorStack, 100);
    initStack(&operandStack, 100);
    int i = 0;
    while (expression[i] != '\0') {
        if (isspace(expression[i])) {
            i++;
            continue;
        }
        if (isdigit(expression[i]) || expression[i] == '.') {  //如果是数字
            double operand = strtod(&expression[i], NULL);
            push(&operandStack, operand);
            while (isdigit(expression[i]) || expression[i] == '.') {
                i++;
            }
            continue;
        } else if (expression[i] == '(') {                    //如果是左括号
            push(&operatorStack, expression[i]);
        } else if (expression[i] == ')') {                    //如果是右括号
            while (!isEmpty(&operatorStack) && peek(&operatorStack) != '(') {
                char op = pop(&operatorStack);
                double num2 = pop(&operandStack);
                double num1 = pop(&operandStack);
                double result = calculate(num1, num2, op);
                push(&operandStack, result);
            }
            if (!isEmpty(&operatorStack) && peek(&operatorStack) == '(') {
                pop(&operatorStack);
            }
        }
        else if(istri(expression[i]))
        {
            int k=istri(expression[i]);
            char numStr[5]; // 定义一个字符串，用于存储数字
            double num=0;
            i=i+4; //转到数值开始的地方
            int j=0;
            while(expression[i] != ')'){
                numStr[j] = expression[i];
                i++;
                j++;
            }
            numStr[j] = '\0'; // 在字符串末尾加上结束符
            switch (k)
            {
            case 1:
                num = sin(atof(numStr) * PI / 180.0);
                break;
            case 2:
                num = cos(atof(numStr)* PI / 180.0);
                break;
            case 3:
                num = tan(atof(numStr)* PI / 180.0);
                break;
            case 4:
                num = exp(atof(numStr));
                break;
             case 5:
                num = log(atof(numStr));
                break;
            default:
                break;
            }
            push(&operandStack, num); // 将浮点数压入操作数栈
            //i++;
        }
         else {
            while (!isEmpty(&operatorStack) && getPriority(expression[i]) <= getPriority(peek(&operatorStack))) {
                char op = pop(&operatorStack);
                double num2 = pop(&operandStack);
                double num1 = pop(&operandStack);
                double result = calculate(num1, num2, op);
                push(&operandStack, result);
            }
            push(&operatorStack, expression[i]);
        }
        i++;
    }
    while (!isEmpty(&operatorStack)) {
        char op = pop(&operatorStack);
        double num2 = pop(&operandStack);
        double num1 = pop(&operandStack);
        double result = calculate(num1, num2, op);
        push(&operandStack, result);
    }
    double finalResult = pop(&operandStack);
    return finalResult;
}

int main() {
	while(1)
	{
	    char expression[100];
    	printf("请输入表达式：");
    	fgets(expression, sizeof(expression), stdin);
    	if(expression[0]=='q') break;
    	double result = evaluateExpression(expression);
    	printf("运算结果为：%.2lf\n", result);	
	}

    return 0;
}
